#!/usr/bin/env bun
/**
 * Build CSS with Headwind
 */
// @ts-ignore - headwind package.json exports are misconfigured
import { build, defaultConfig } from '../node_modules/@stacksjs/headwind/dist/index.js'
import { writeFileSync, mkdirSync, existsSync } from 'node:fs'
import { resolve, dirname } from 'node:path'

console.log('Building CSS with Headwind...')

const outputPath = resolve(import.meta.dir, '../public/dist/voide.css')

// Monokai Pro color palette
const monokaiColors = {
  bg: '#2d2a2e',
  'bg-dark': '#221f22',
  fg: '#fcfcfa',
  pink: '#ff6188',
  orange: '#fc9867',
  yellow: '#ffd866',
  green: '#a9dc76',
  cyan: '#78dce8',
  purple: '#ab9df2',
  gray: '#727072',
  border: '#403e41',
}

const config = {
  ...defaultConfig,
  content: [
    resolve(import.meta.dir, '../pages/**/*.stx'),
    resolve(import.meta.dir, '../components/**/*.stx'),
  ],
  output: outputPath,
  minify: false,
  safelist: [
    // Animations (dynamically applied)
    'animate-pulse',
    'animate-bounce',
    'animate-fade-in',
    'animate-blink',
    // Transform utilities (for collapse icons)
    'rotate-180',
    'transition-transform',
    // Z-index for collapse button
    'z-10',
    // Code blocks
    'font-mono',
  ],
  theme: {
    extend: {
      colors: {
        monokai: monokaiColors,
      },
    },
  },
}

try {
  // Ensure output directory exists
  const outputDir = dirname(outputPath)
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true })
  }

  // Build CSS using Headwind API
  const result = await build(config)

  // Additional utilities that Headwind doesn't generate automatically
  // (gradients, placeholder colors, complex shadow combinations)
  const additionalUtilities = `
/* Monokai CSS Variables for consistent theming */
:root {
  --monokai-bg: ${monokaiColors.bg};
  --monokai-bg-dark: ${monokaiColors['bg-dark']};
  --monokai-fg: ${monokaiColors.fg};
  --monokai-pink: ${monokaiColors.pink};
  --monokai-orange: ${monokaiColors.orange};
  --monokai-yellow: ${monokaiColors.yellow};
  --monokai-green: ${monokaiColors.green};
  --monokai-cyan: ${monokaiColors.cyan};
  --monokai-purple: ${monokaiColors.purple};
  --monokai-gray: ${monokaiColors.gray};
  --monokai-border: ${monokaiColors.border};
}

/* Placeholder colors (not auto-generated by headwind) */
.placeholder-monokai-gray::placeholder { color: var(--monokai-gray); }

/* Gradient stops with monokai colors */
.from-monokai-purple { --hw-gradient-from: var(--monokai-purple); --hw-gradient-to: transparent; --hw-gradient-stops: var(--hw-gradient-from), var(--hw-gradient-to); }
.from-monokai-cyan { --hw-gradient-from: var(--monokai-cyan); --hw-gradient-to: transparent; --hw-gradient-stops: var(--hw-gradient-from), var(--hw-gradient-to); }
.from-monokai-fg { --hw-gradient-from: var(--monokai-fg); --hw-gradient-to: transparent; --hw-gradient-stops: var(--hw-gradient-from), var(--hw-gradient-to); }
.to-monokai-purple { --hw-gradient-to: var(--monokai-purple); --hw-gradient-stops: var(--hw-gradient-from), var(--hw-gradient-to); }
.to-monokai-cyan { --hw-gradient-to: var(--monokai-cyan); --hw-gradient-stops: var(--hw-gradient-from), var(--hw-gradient-to); }
.to-monokai-fg { --hw-gradient-to: var(--monokai-fg); --hw-gradient-stops: var(--hw-gradient-from), var(--hw-gradient-to); }
.to-monokai-fg\\/60 { --hw-gradient-to: rgba(252, 252, 250, 0.6); --hw-gradient-stops: var(--hw-gradient-from), var(--hw-gradient-to); }

/* Shadow utilities with Monokai colors (combined selectors) */
.shadow-lg.shadow-monokai-purple\\/25 { box-shadow: 0 10px 15px -3px rgba(171, 157, 242, 0.25), 0 4px 6px -4px rgba(171, 157, 242, 0.25); }
.shadow-lg.shadow-monokai-green\\/25 { box-shadow: 0 10px 15px -3px rgba(169, 220, 118, 0.25), 0 4px 6px -4px rgba(169, 220, 118, 0.25); }
.shadow-lg.shadow-monokai-cyan\\/25 { box-shadow: 0 10px 15px -3px rgba(120, 220, 232, 0.25), 0 4px 6px -4px rgba(120, 220, 232, 0.25); }
`

  // Write CSS file with additional utilities appended
  writeFileSync(outputPath, result.css + additionalUtilities)

  const sizeKB = (result.css.length / 1024).toFixed(2)
  console.log(`CSS built: ${result.classes.size} classes in ${result.duration.toFixed(1)}ms`)
  console.log(`Output: ${sizeKB} KB -> public/dist/voide.css`)
} catch (error) {
  console.error('Failed to build CSS:', error)
  // Don't exit with error - CSS is optional for development
  console.log('Continuing without CSS build...')
}

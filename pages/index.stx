<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Voide - Voice AI Code Assistant</title>

  <style>
    /* Custom animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-4px); }
    }
    @keyframes float {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      50% { transform: translateY(-20px) rotate(5deg); }
    }

    .animate-fade-in { animation: fadeIn 0.4s ease-out; }
    .animate-pulse { animation: pulse 2s ease-in-out infinite; }
    .animate-bounce { animation: bounce 0.6s ease-in-out infinite; }

    /* Custom scrollbar */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.2); }

    /* Body styling */
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    /* Monokai Pro background */
    .gradient-bg {
      background: #221f22;
      position: relative;
    }

    /* Floating orbs - Monokai colors */
    .orb {
      position: absolute;
      border-radius: 50%;
      filter: blur(80px);
      opacity: 0.15;
      animation: float 20s ease-in-out infinite;
    }
    .orb-1 {
      width: 400px;
      height: 400px;
      background: linear-gradient(to right, #ab9df2, #78dce8);
      top: -100px;
      right: -100px;
      animation-delay: 0s;
    }
    .orb-2 {
      width: 300px;
      height: 300px;
      background: linear-gradient(to right, #ff6188, #ab9df2);
      bottom: -50px;
      left: -50px;
      animation-delay: -10s;
    }
  </style>

  <!-- Load Headwind CSS -->
  <script>
    // Dynamically load Headwind CSS to bypass bundler
    (() => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = '/dist/voide.css';
      link.onload = () => {
        if (document.body) {
          document.body.style.visibility = 'visible';
        }
      };
      document.head.appendChild(link);
      // Hide body until CSS loads to prevent FOUC
      document.write('<style>body{visibility:hidden}</style>');
    })();
  </script>

  <!-- Voide Stores (loaded synchronously before body parses) -->
  <script>
    // Use document.write to load synchronously and bypass bundler resolution
    document.write('<scr' + 'ipt src="/js/voide-stores.js"></scr' + 'ipt>');
  </script>
  <script>
    if (window.VoideStores) {
      console.log('[Voide] Stores loaded successfully');
    } else {
      console.error('[Voide] Failed to load stores!');
    }
  </script>

</head>
<body class="gradient-bg flex flex-col h-screen text-white overflow-hidden">
  <!-- Floating orbs -->
  <div class="orb orb-1"></div>
  <div class="orb orb-2"></div>

  <!-- Header -->
  @include('../components/voide/header')

  <!-- Main Content -->
  <main class="relative flex-1 flex flex-col p-6 gap-5 overflow-hidden">
    <!-- Terminal -->
    @include('../components/voide/terminal')

    <!-- Input Bar -->
    @include('../components/voide/input-bar')
  </main>

  <!-- Footer -->
  <footer style="position:relative;padding:12px 24px;text-align:center;font-size:12px;color:#727072;border-top:1px solid #403e41">
    <span style="background:linear-gradient(to right,#ab9df2,#78dce8);-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-weight:500">Voide</span>
    <span style="margin:0 8px">Â·</span>
    <span>v1.0.0</span>
    <span style="margin:0 8px">Â·</span>
    <span>Voice AI Code Assistant</span>
  </footer>

  <!-- Modals -->
  @include('../components/voide/modals')

  <!-- Craft Native Bridge -->
  <script>
    (() => {
      if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.craftBridge) {
        window.craft = {
          _callbacks: {},
          _callbackId: 0,
          _invoke: function(method, args) {
            args = args || {};
            const self = this;
            return new Promise(function(resolve, reject) {
              const id = ++self._callbackId;
              self._callbacks[id] = { resolve: resolve, reject: reject };
              window.webkit.messageHandlers.craftBridge.postMessage({ id: id, method: method, args: args });
            });
          },
          _handleResponse: function(id, result, error) {
            const cb = this._callbacks[id];
            if (cb) {
              delete this._callbacks[id];
              error ? cb.reject(new Error(error)) : cb.resolve(result);
            }
          },
          window: {
            setTitle: function(title) { return window.craft._invoke('window.setTitle', { title: title }); },
            close: () => { return window.craft._invoke('window.close'); },
            minimize: () => { return window.craft._invoke('window.minimize'); },
            maximize: () => { return window.craft._invoke('window.maximize'); }
          },
          tray: {
            setTitle: function(title) { return window.craft._invoke('tray.setTitle', { title: title }); },
            setTooltip: function(tooltip) { return window.craft._invoke('tray.setTooltip', { tooltip: tooltip }); },
            setMenu: function(menu) { return window.craft._invoke('tray.setMenu', { menu: menu }); },
            onClickToggleWindow: () => { return window.craft._invoke('tray.onClickToggleWindow'); }
          },
          app: {
            quit: () => { return window.craft._invoke('app.quit'); },
            notify: function(options) { return window.craft._invoke('app.notify', options); }
          }
        };
        console.log('[Voide] Craft native bridge initialized');
      }
    })();
  </script>

  <!-- Voide Client Runtime (Plain JS - No ES Modules) -->
  <script>
    (() => {
      'use strict';

      // ==========================================================================
      // Store References (from VoideStores)
      // ==========================================================================

      function initVoide() {
        const stores = window.VoideStores;
        if (!stores) {
          console.error('[Voide] CRITICAL: VoideStores not available! App will not function.');
          document.body.innerHTML = '<div style="padding:20px;color:red;">Error: Stores failed to load. Check console for details.</div>';
          return;
        }
        console.log('[Voide] Stores found, initializing app...');
        setupApp(stores);
      }

      // Wait for stores if not immediately available
      if (window.VoideStores) {
        initVoide();
      } else {
        console.log('[Voide] Waiting for stores to load...');
        let checkCount = 0;
        const checkInterval = setInterval(() => {
          checkCount++;
          if (window.VoideStores) {
            clearInterval(checkInterval);
            initVoide();
          } else if (checkCount > 50) { // 5 seconds max
            clearInterval(checkInterval);
            console.error('[Voide] Stores failed to load after 5 seconds');
            document.body.innerHTML = '<div style="padding:20px;color:red;">Error: Stores failed to load. Check console for details.</div>';
          }
        }, 100);
      }

      function setupApp(stores) {

      const appStore = stores.appStore;
      const appActions = stores.appActions;
      const chatStore = stores.chatStore;
      const chatActions = stores.chatActions;
      const settingsStore = stores.settingsStore;
      const settingsActions = stores.settingsActions;
      const uiStore = stores.uiStore;
      const uiActions = stores.uiActions;

      // Initialize speech recognition using the composable
      const speechRecognition = stores.useSpeechRecognition({
        continuous: false,
        interimResults: true,
        lang: 'en-US'
      });

      const config = {
        title: 'Voide',
        version: '1.0.0',
        apiBaseUrl: 'http://localhost:3008/voide',
        drivers: {
          'claude-cli-local': { name: 'Claude CLI (Local)', requiresKey: null },
          'claude-cli-ec2': { name: 'Claude CLI (EC2)', requiresKey: 'BUDDY_EC2_HOST' },
          'claude': { name: 'Claude API', requiresKey: 'ANTHROPIC_API_KEY' },
          'openai': { name: 'OpenAI', requiresKey: 'OPENAI_API_KEY' },
          'ollama': { name: 'Ollama', requiresKey: null },
          'mock': { name: 'Mock', requiresKey: null }
        }
      };

      // ==========================================================================
      // Helper Functions (wrapping store actions)
      // ==========================================================================

      function saveChat() {
        const app = appStore.get();
        chatActions.saveCurrentChat(app.repoPath, app.currentDriver);
      }

      function loadChat(chatId) {
        const success = chatActions.loadChat(chatId);
        if (success) {
          const chats = chatActions.getAllChats();
          const chat = chats[chatId];
          if (chat) {
            appActions.setRepoPath(chat.repoPath || '');
            appActions.setDriver(chat.driver || 'claude-cli-local');
            // Store will update the input via x-model binding
          }
        }
        return success;
      }

      function startNewChat() {
        const app = appStore.get();
        return chatActions.startNewChat(app.repoPath, app.currentDriver);
      }

      function getCurrentDriverName() {
        const app = appStore.get();
        const driver = config.drivers[app.currentDriver];
        return driver ? driver.name : 'AI';
      }

      // ==========================================================================
      // Methods
      // ==========================================================================

      function addMessage(type, content, header) {
        const driverName = getCurrentDriverName();
        const headerText = header || (type === 'user' ? 'You' : type === 'assistant' ? driverName : type === 'system' ? 'System' : 'Error');

        chatActions.addMessage(type, content, headerText);

        // Save chat to localStorage
        saveChat();

        // Only scroll to bottom when user sends a new prompt
        if (type === 'user') {
          setTimeout(() => {
            const output = document.getElementById('output');
            if (output) output.scrollTop = output.scrollHeight;
          }, 10);
        }
      }

      function checkBackendAPI() {
        return fetch(config.apiBaseUrl + '/state')
          .then((res) => { return res.ok; })
          .catch(() => { return false; });
      }

      let saveChatDebounceTimer = null;
      function updateLastMessage(type, content) {
        chatActions.updateLastMessage(type, content);

        // Debounce save during streaming to avoid excessive writes
        clearTimeout(saveChatDebounceTimer);
        saveChatDebounceTimer = setTimeout(saveChat, 500);
      }

      function processWithStreaming(command) {
        return new Promise(function(resolve, reject) {
          let fullContent = '';
          let currentEvent = '';
          const app = appStore.get();

          fetch(config.apiBaseUrl + '/process/stream', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              command: command,
              driver: app.currentDriver,
              repository: app.repoPath
            })
          }).then((response) => {
            if (!response.ok) {
              throw new Error('Stream request failed');
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            const buffer = '';

            function readChunk() {
              reader.read().then(function(result) {
                if (result.done) {
                  resolve({ message: fullContent, hasChanges: false });
                  return;
                }

                buffer += decoder.decode(result.value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';

                for (const i = 0; i < lines.length; i++) {
                  const line = lines[i].trim();
                  if (!line) continue;

                  if (line.indexOf('event: ') === 0) {
                    currentEvent = line.substring(7);
                    continue;
                  }

                  if (line.indexOf('data: ') === 0) {
                    try {
                      const data = JSON.parse(line.substring(6));

                      if (currentEvent === 'chunk' && data.text) {
                        fullContent += data.text;
                        updateLastMessage('assistant', fullContent);
                      } else if (currentEvent === 'done') {
                        resolve({ message: fullContent, hasChanges: data.hasChanges || false });
                        return;
                      } else if (currentEvent === 'error') {
                        reject(new Error(data.error || 'Stream error'));
                        return;
                      }
                    } catch (e) {
                      // Ignore parse errors
                    }
                  }
                }

                readChunk();
              }).catch(reject);
            }

            readChunk();
          }).catch(reject);
        });
      }

      function processCommand(command) {
        if (!command.trim()) return;

        const chat = chatStore.get();
        const app = appStore.get();

        // Start a new chat on first prompt if not already in a chat
        if (!chat.currentChatId) {
          // Create the user message first, then start chat with it included
          // This ensures the message is saved to localStorage BEFORE the URL change
          const userMessage = {
            type: 'user',
            content: command,
            header: 'You',
            timestamp: Date.now()
          };
          chatActions.startNewChat(app.repoPath, app.currentDriver, userMessage);
        } else {
          addMessage('user', command);
        }
        appActions.setTerminalTitle('Processing...');

        if (!app.repoPath) {
          addMessage('error', 'Please enter a repository URL or path first.');
          appActions.setTerminalTitle(config.title + ' - Ready');
          return;
        }

        appActions.setProcessing(true);
        addMessage('assistant', '...');

        checkBackendAPI().then((hasBackend) => {
          if (hasBackend) {
            // Use streaming endpoint
            return processWithStreaming(command);
          } else if (appStore.get().currentDriver === 'mock') {
            return new Promise(function(resolve) {
              setTimeout(() => {
                resolve({
                  message: '[Mock] Processing: "' + command + '"\n\nThis is a simulated response.',
                  hasChanges: command.toLowerCase().indexOf('fix') !== -1
                });
              }, 1500);
            });
          } else {
            return Promise.reject(new Error('Backend API not available. Start the server at localhost:3008.'));
          }
        }).then((response) => {
          // Streaming already updated the message, just handle completion
          if (response.hasChanges) {
            appActions.setHasChanges(true);
            addMessage('system', 'Changes staged. Click "Commit Changes" to create a commit.');
            sendNotification('Changes Ready', 'Code changes are staged.');
          }

          appActions.setTerminalTitle(config.title + ' - Ready');
          updateTrayStatus('success');
          setTimeout(() => { updateTrayStatus('ready'); }, 2000);
        }).catch((error) => {
          chatActions.removeLastMessage();
          addMessage('error', 'Failed: ' + error.message);
          appActions.setTerminalTitle(config.title + ' - Error');
          updateTrayStatus('error');
          setTimeout(() => { updateTrayStatus('ready'); }, 3000);
        }).finally(() => {
          appActions.setProcessing(false);
        });
      }

      function handleRepoAction() {
        const input = document.getElementById('repoInput');
        const inputValue = input ? input.value.trim() : '';

        if (!inputValue) {
          addMessage('error', 'Please enter a repository URL or path.');
          return;
        }

        addMessage('system', 'Opening repository: ' + inputValue);

        checkBackendAPI().then((hasBackend) => {
          if (hasBackend) {
            return fetch(config.apiBaseUrl + '/repo', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ input: inputValue })
            }).then((res) => { return res.json(); });
          } else {
            return {
              success: true,
              data: {
                repo: { path: inputValue, name: inputValue.split('/').pop(), branch: 'main' }
              }
            };
          }
        }).then((response) => {
          // Handle both wrapped {success, data} and direct response formats
          const data = response.data || response;
          const repo = data.repo;

          if (repo) {
            appActions.setRepoPath(repo.path);
            settingsActions.setLastRepoPath(repo.path);
            saveChat(); // Save repo path to chat
            addMessage('system', 'Repository "' + repo.name + '" opened.\nPath: ' + repo.path + '\nBranch: ' + repo.branch);
            appActions.setTerminalTitle(config.title + ' - ' + repo.name);
          } else if (response.error) {
            throw new Error(response.error);
          } else {
            throw new Error('Failed to open repository');
          }
        }).catch((error) => {
          addMessage('error', 'Failed: ' + error.message);
        });
      }

      function commitChanges() {
        if (!appStore.get().hasChanges) return;

        addMessage('system', 'Creating commit...');
        updateTrayStatus('processing');

        checkBackendAPI().then((hasBackend) => {
          if (hasBackend) {
            return fetch(config.apiBaseUrl + '/commit', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
            }).then((res) => { return res.json(); });
          } else {
            return { success: true, hash: 'mock-commit-hash' };
          }
        }).then((response) => {
          addMessage('system', 'Committed: ' + (response.hash || 'success'));
          appActions.setHasChanges(false);
          updateTrayStatus('success');
          setTimeout(() => { updateTrayStatus('ready'); }, 2000);
        }).catch((error) => {
          addMessage('error', 'Failed: ' + error.message);
          updateTrayStatus('error');
          setTimeout(() => { updateTrayStatus('ready'); }, 3000);
        });
      }

      function pushChanges() {
        addMessage('system', 'Pushing to remote...');
        updateTrayStatus('processing');

        checkBackendAPI().then((hasBackend) => {
          if (hasBackend) {
            return fetch(config.apiBaseUrl + '/push', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
            });
          }
          return Promise.resolve();
        }).then(() => {
          addMessage('system', 'Pushed successfully.');
          updateTrayStatus('success');
          setTimeout(() => { updateTrayStatus('ready'); }, 2000);
        }).catch((error) => {
          addMessage('error', 'Failed: ' + error.message);
          updateTrayStatus('error');
          setTimeout(() => { updateTrayStatus('ready'); }, 3000);
        });
      }

      // ==========================================================================
      // Speech Recognition (using composable)
      // ==========================================================================

      function initSpeechRecognition() {
        if (!speechRecognition.isSupported) {
          appActions.setSpeechSupported(false);
          addMessage('system', 'Speech recognition not available. Please use text input.');
          return false;
        }

        // Subscribe to speech recognition events
        speechRecognition.on('start', () => {
          const app = appStore.get();
          // Only clear transcript on fresh start, not on restart
          if (!app.isRecording) {
            appActions.setTranscript('');
          }
          appActions.setRecording(true);
          updateTrayStatus('recording');
        });

        // Track accumulated transcript across restarts (stored in app state scope)
        let accumulatedTranscript = '';

        speechRecognition.on('result', (data) => {
          // Combine accumulated transcript with current result
          const fullTranscript = accumulatedTranscript + data.transcript;
          appActions.setTranscript(fullTranscript);
        });

        // When recognition ends and restarts, save the final transcript
        speechRecognition.on('end', (data) => {
          const app = appStore.get();
          if (app.isRecording) {
            // Save current transcript before restart clears it
            accumulatedTranscript = app.transcript + ' ';
            speechRecognition.start();
          } else {
            // User stopped - reset accumulated
            accumulatedTranscript = '';
          }
        });

        // Expose reset function for startRecording
        window._resetAccumulatedTranscript = () => {
          accumulatedTranscript = '';
        };

        speechRecognition.on('error', (data) => {
          console.error('Speech recognition error:', data.code);
          stopRecording();
          if (data.code !== 'aborted' && data.code !== 'no-speech') {
            addMessage('error', data.message);
          }
        });

        appActions.setSpeechSupported(true);
        return true;
      }

      function startRecording() {
        const app = appStore.get();
        if (!app.speechSupported || app.isRecording) return;
        appActions.setTranscript('');
        if (window._resetAccumulatedTranscript) {
          window._resetAccumulatedTranscript();
        }
        speechRecognition.start();
      }

      function stopRecording() {
        appActions.setRecording(false);
        updateTrayStatus('ready');
        speechRecognition.stop();
      }

      function toggleRecording() {
        const app = appStore.get();
        if (app.isRecording) {
          stopRecording();
        } else {
          startRecording();
        }
      }

      // ==========================================================================
      // Native App Features
      // ==========================================================================

      function initNativeFeatures() {
        if (!window.craft) return;

        appActions.setNativeApp(true);
        try {
          window.craft.tray.setTitle('Voide');
          window.craft.tray.setTooltip('Voide - Voice AI Code Assistant');
          window.craft.tray.setMenu([
            { id: 'show', label: 'Show Voide', action: 'show' },
            { id: 'hide', label: 'Hide Window', action: 'hide' },
            { type: 'separator' },
            { id: 'recording', label: 'Start Recording', action: 'startRecording' },
            { type: 'separator' },
            { id: 'quit', label: 'Quit Voide', action: 'quit', shortcut: 'Cmd+Q' }
          ]);
          window.craft.tray.onClickToggleWindow();
          addMessage('system', 'Running as native app - system tray enabled');
        } catch (e) {
          console.log('Native features not fully available:', e);
        }
      }

      function updateTrayStatus(status) {
        if (!appStore.get().isNativeApp || !window.craft) return;
        const icons = { ready: 'ðŸ¤–', recording: 'ðŸ”´', processing: 'â³', success: 'âœ…', error: 'âŒ' };
        try {
          window.craft.tray.setTitle((icons[status] || 'ðŸ¤–') + ' Voide');
        } catch (e) {}
      }

      function sendNotification(title, body) {
        if (!appStore.get().isNativeApp || !window.craft) return;
        try {
          window.craft.app.notify({ title: title, body: body });
        } catch (e) {}
      }

      // ==========================================================================
      // Modal Functions
      // ==========================================================================

      function openGithubModal() {
        uiActions.openModal('github');
      }

      function closeGithubModal() {
        uiActions.closeModal('github');
      }

      function openSettingsModal() {
        uiActions.openModal('settings');
      }

      function closeSettingsModal() {
        uiActions.closeModal('settings');
      }

      function saveApiSettings() {
        const anthropicInput = document.getElementById('anthropicApiKey');
        const openaiInput = document.getElementById('openaiApiKey');
        const claudeHostInput = document.getElementById('claudeCliHost');

        settingsActions.setAllApiKeys({
          anthropic: anthropicInput ? anthropicInput.value.trim() || null : null,
          openai: openaiInput ? openaiInput.value.trim() || null : null,
          claudeCliHost: claudeHostInput ? claudeHostInput.value.trim() || null : null
        });

        closeSettingsModal();
        addMessage('system', 'API settings saved.');
      }

      function connectGithub() {
        const tokenInput = document.getElementById('githubToken');
        const nameInput = document.getElementById('gitName');
        const emailInput = document.getElementById('gitEmail');

        const token = tokenInput ? tokenInput.value.trim() : '';
        if (!token) {
          addMessage('error', 'Please enter a GitHub personal access token.');
          return;
        }

        // Validate token by fetching user info from GitHub API
        fetch('https://api.github.com/user', {
          headers: {
            'Authorization': 'token ' + token,
            'Accept': 'application/vnd.github.v3+json'
          }
        })
        .then((res) => {
          if (!res.ok) throw new Error('Invalid token');
          return res.json();
        })
        .then(function(user) {
          settingsActions.connectGithub({
            token: token,
            username: user.login,
            name: nameInput ? nameInput.value.trim() || user.name : user.name,
            email: emailInput ? emailInput.value.trim() || user.email : user.email,
            avatarUrl: user.avatar_url
          });
          addMessage('system', 'Connected to GitHub as @' + user.login);
          closeGithubModal();
        })
        .catch((error) => {
          addMessage('error', 'GitHub connection failed: ' + error.message);
        });
      }

      function disconnectGithub() {
        settingsActions.disconnectGithub();
        addMessage('system', 'Disconnected from GitHub.');
        closeGithubModal();
      }

      // ==========================================================================
      // Text Input Handling
      // ==========================================================================

      function handleTextSubmit() {
        const chat = chatStore.get();
        const text = chat.inputText.trim();
        if (text && !appStore.get().isProcessing) {
          chatActions.clearInput();
          processCommand(text);
        }
      }

      function handleDriverChange(event) {
        appActions.setDriver(event.target.value);
        addMessage('system', 'Switched to ' + config.drivers[event.target.value].name);
      }

      // ==========================================================================
      // Initialization
      // ==========================================================================

      function init() {
        console.log('[Voide] Initializing...');
        console.log('[Voide] VoideStores available:', !!window.VoideStores);
        console.log('[Voide] VoideTerminal available:', !!window.VoideTerminal);

        // Initialize native features
        initNativeFeatures();

        // Initialize speech recognition
        initSpeechRecognition();

        // Check URL for existing chat
        const chatIdFromUrl = chatActions.getChatIdFromUrl();
        if (chatIdFromUrl) {
          if (!loadChat(chatIdFromUrl)) {
            // Chat not found, redirect to home
            history.replaceState({}, '', '/');
          }
        } else {
          // No chat in URL, load last repo path for new session
          const settings = settingsStore.get();
          if (settings.lastRepoPath) {
            appActions.setRepoPath(settings.lastRepoPath);
            const repoInput = document.getElementById('repoInput');
            if (repoInput) repoInput.value = settings.lastRepoPath;
          }
        }

        // Handle browser back/forward navigation
        window.addEventListener('popstate', (e) => {
          const chatId = chatActions.getChatIdFromUrl();
          if (chatId) {
            loadChat(chatId);
          } else {
            // Navigated to home, clear current chat
            chatActions.newChat();
          }
        });

        // Setup keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          if (e.code === 'Space' && !e.repeat) {
            const active = document.activeElement;
            const isInput = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA');
            if (!isInput) {
              e.preventDefault();
              toggleRecording();
            }
          }
          if (e.key === 'Escape') {
            uiActions.closeAllModals();
            // Also stop recording if active
            if (appStore.get().isRecording) {
              stopRecording();
            }
          }
        });
      }

      // ==========================================================================
      // Expose to window for component access
      // ==========================================================================

      window.voide = {
        // Stores (reactive)
        stores: stores,
        appStore: appStore,
        chatStore: chatStore,
        settingsStore: settingsStore,
        uiStore: uiStore,

        // Store actions
        appActions: appActions,
        chatActions: chatActions,
        settingsActions: settingsActions,
        uiActions: uiActions,

        // Composables (Nuxt-style browser API utilities)
        useStorage: stores.useStorage,
        useLocalStorage: stores.useLocalStorage,
        useSessionStorage: stores.useSessionStorage,
        useCookie: stores.useCookie,
        useClipboard: stores.useClipboard,
        useMediaQuery: stores.useMediaQuery,
        usePreferredDark: stores.usePreferredDark,
        useNetwork: stores.useNetwork,
        useOnline: stores.useOnline,
        useWindowSize: stores.useWindowSize,
        useScroll: stores.useScroll,
        useVisibility: stores.useVisibility,
        useTitle: stores.useTitle,
        useFavicon: stores.useFavicon,
        useIsMobile: stores.useIsMobile,
        useIsDesktop: stores.useIsDesktop,
        copyToClipboard: stores.copyToClipboard,

        // Legacy accessors (for component compatibility)
        get state() { return appStore.get(); },
        get messages() { return chatStore.get().messages; },
        get charCount() { return chatStore.get().charCount; },

        // Config
        config: config,
        getCurrentDriverName: getCurrentDriverName,

        // Methods
        addMessage: addMessage,
        processCommand: processCommand,
        handleRepoAction: handleRepoAction,
        commitChanges: commitChanges,
        pushChanges: pushChanges,
        startRecording: startRecording,
        stopRecording: stopRecording,
        toggleRecording: toggleRecording,
        handleTextSubmit: handleTextSubmit,
        handleDriverChange: handleDriverChange,
        openGithubModal: openGithubModal,
        closeGithubModal: closeGithubModal,
        connectGithub: connectGithub,
        disconnectGithub: disconnectGithub,
        openSettingsModal: openSettingsModal,
        closeSettingsModal: closeSettingsModal,
        saveApiSettings: saveApiSettings,

        // Chat management
        newChat: chatActions.newChat,
        loadChat: loadChat,
        getAllChats: chatActions.getAllChats,
        deleteChat: chatActions.deleteChat
      };

      // Initialize when DOM is ready
      console.log('[Voide] Setting up window.voide object...');
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
      console.log('[Voide] window.voide created with methods:', Object.keys(window.voide).join(', '));
      } // end setupApp function
    })();
  </script>
</body>
</html>

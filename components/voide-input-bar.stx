<template>
  <div class="max-w-3xl mx-auto w-full">
    <!-- Thinking indicator - shown above input when processing -->
    <div id="thinkingIndicator" class="hidden mb-3 px-4">
      <div class="flex items-center gap-2 text-monokai-gray/70">
        <div class="flex gap-1">
          <span class="w-1.5 h-1.5 bg-monokai-purple rounded-full animate-bounce" style="animation-delay: 0ms"></span>
          <span class="w-1.5 h-1.5 bg-monokai-purple rounded-full animate-bounce" style="animation-delay: 150ms"></span>
          <span class="w-1.5 h-1.5 bg-monokai-purple rounded-full animate-bounce" style="animation-delay: 300ms"></span>
        </div>
        <span class="text-sm italic">thinking...</span>
        <span id="thinkingTimer" class="opacity-40 font-mono" style="font-size: 10px">0.0s</span>
      </div>
    </div>

    <!-- Audio Preview (shown after recording stops) -->
    <div id="audioPreview" class="hidden mb-3">
      <div class="bg-monokai-bg-dark border border-monokai-cyan rounded-xl p-3">
        <!-- Audio player row -->
        <div class="flex items-center gap-3">
          <!-- Play/Pause button -->
          <button
            id="audioPlayBtn"
            class="w-10 h-10 rounded-full bg-monokai-cyan/20 text-monokai-cyan hover:bg-monokai-cyan/30 flex items-center justify-center transition-colors"
            title="Play audio"
          >
            <svg id="audioPlayIcon" class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
              <path d="M8 5v14l11-7z"/>
            </svg>
          </button>

          <!-- Waveform placeholder / Duration -->
          <div class="flex-1">
            <div class="flex items-center gap-2">
              <div id="audioWaveform" class="flex-1 h-8 bg-monokai-bg rounded flex items-center justify-center gap-0.5 px-2">
                <!-- Simple bar visualization -->
                <div class="w-1 bg-monokai-cyan/40 rounded-full" style="height: 30%"></div>
                <div class="w-1 bg-monokai-cyan/60 rounded-full" style="height: 50%"></div>
                <div class="w-1 bg-monokai-cyan/80 rounded-full" style="height: 80%"></div>
                <div class="w-1 bg-monokai-cyan rounded-full" style="height: 100%"></div>
                <div class="w-1 bg-monokai-cyan/80 rounded-full" style="height: 70%"></div>
                <div class="w-1 bg-monokai-cyan/60 rounded-full" style="height: 40%"></div>
                <div class="w-1 bg-monokai-cyan/40 rounded-full" style="height: 60%"></div>
                <div class="w-1 bg-monokai-cyan/60 rounded-full" style="height: 90%"></div>
                <div class="w-1 bg-monokai-cyan/80 rounded-full" style="height: 50%"></div>
                <div class="w-1 bg-monokai-cyan/40 rounded-full" style="height: 30%"></div>
              </div>
              <span id="audioDuration" class="text-xs text-monokai-gray font-mono">0:00</span>
            </div>
          </div>

          <!-- Delete audio -->
          <button
            id="audioDeleteBtn"
            class="w-8 h-8 rounded-lg text-monokai-gray hover:text-monokai-pink hover:bg-monokai-pink/10 flex items-center justify-center transition-colors"
            title="Delete recording"
          >
            <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
            </svg>
          </button>
        </div>

        <!-- Transcription toggle -->
        <div class="mt-2 pt-2 border-t border-monokai-border/30">
          <button
            id="transcriptToggle"
            class="flex items-center gap-2 text-xs text-monokai-gray hover:text-monokai-fg transition-colors"
          >
            <svg id="transcriptChevron" class="w-3 h-3 transition-transform" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"/>
            </svg>
            <span>View transcription</span>
            <span id="transcriptStatus" class="text-monokai-purple"></span>
          </button>

          <!-- Transcription text (collapsible) -->
          <div id="transcriptContent" class="hidden mt-2">
            <textarea
              id="transcriptText"
              class="w-full bg-monokai-bg text-sm text-monokai-fg border border-monokai-border/50 rounded-lg p-2 resize-none min-h-[60px] max-h-[120px] outline-none focus:border-monokai-cyan"
              placeholder="Transcription will appear here..."
            ></textarea>
          </div>
        </div>
      </div>
    </div>

    <div
      id="inputContainer"
      class="bg-monokai-bg-dark border border-monokai-border rounded-2xl px-4 py-3"
    >
      <!-- Recording mode indicator (replaces textarea when recording) -->
      <div id="recordingMode" class="hidden">
        <div class="flex items-center justify-center gap-4 py-2">
          <!-- Recording pulse -->
          <div class="w-3 h-3 bg-monokai-pink rounded-full animate-pulse"></div>
          <!-- Timer -->
          <span id="recordingTimer" class="text-2xl font-mono text-monokai-fg">0:00</span>
        </div>
      </div>

      <!-- Input row (hidden when recording) -->
      <div id="inputRow" class="flex items-end gap-3">
        <textarea
          id="textInput"
          class="flex-1 bg-transparent text-sm text-monokai-fg border-none outline-none resize-none min-h-[24px] max-h-[160px] leading-6 placeholder-monokai-gray"
          placeholder="Type or click mic to record"
          rows="1"
        ></textarea>
      </div>

      <!-- Bottom bar -->
      <div class="flex items-center justify-between mt-3 pt-3 border-t border-monokai-border/50">
        <div class="flex items-center gap-2">
          <!-- Attachment button -->
          <button
            class="w-8 h-8 rounded-lg flex items-center justify-center text-monokai-gray hover:text-monokai-fg hover:bg-monokai-bg transition-colors"
            title="Attach file"
          >
            <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15"></path></svg>
          </button>

          <!-- Voice/Mic button -->
          <button
            id="micButton"
            class="w-8 h-8 rounded-lg flex items-center justify-center text-monokai-gray hover:text-monokai-fg hover:bg-monokai-bg transition-colors"
            title="Record voice message"
          >
            <svg id="micIcon" class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18.75a6 6 0 006-6v-1.5m-6 7.5a6 6 0 01-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 01-3-3V4.5a3 3 0 116 0v8.25a3 3 0 01-3 3z"></path></svg>
          </button>

          <!-- Volume Level Indicator (5 bars) -->
          <div id="volumeIndicator" class="hidden flex items-end gap-0.5 h-5 px-1">
            <div id="volBar1" class="w-1 bg-monokai-gray/30 rounded-full transition-colors" style="height: 20%"></div>
            <div id="volBar2" class="w-1 bg-monokai-gray/30 rounded-full transition-colors" style="height: 40%"></div>
            <div id="volBar3" class="w-1 bg-monokai-gray/30 rounded-full transition-colors" style="height: 60%"></div>
            <div id="volBar4" class="w-1 bg-monokai-gray/30 rounded-full transition-colors" style="height: 80%"></div>
            <div id="volBar5" class="w-1 bg-monokai-gray/30 rounded-full transition-colors" style="height: 100%"></div>
          </div>

          <!-- Driving Mode toggle -->
          <button
            id="drivingModeBtn"
            class="w-8 h-8 rounded-lg flex items-center justify-center text-monokai-gray hover:text-monokai-fg hover:bg-monokai-bg transition-colors"
            title="Driving Mode (hands-free)"
          >
            <svg id="drivingIcon" class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 18.75a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m3 0h6m-9 0H3.375a1.125 1.125 0 01-1.125-1.125V14.25m17.25 4.5a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m3 0h1.125c.621 0 1.129-.504 1.09-1.124a17.902 17.902 0 00-3.213-9.193 2.056 2.056 0 00-1.58-.86H14.25M16.5 18.75h-2.25m0-11.177v-.958c0-.568-.422-1.048-.987-1.106a48.554 48.554 0 00-10.026 0 1.106 1.106 0 00-.987 1.106v7.635m12-6.677v6.677m0 4.5v-4.5m0 0h-12"></path></svg>
          </button>

          <!-- Stop button (shown when processing) -->
          <button
            id="stopBtn"
            class="hidden w-8 h-8 rounded-lg flex items-center justify-center bg-monokai-pink/20 text-monokai-pink hover:bg-monokai-pink/30 transition-colors"
            title="Stop"
          >
            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><rect x="6" y="6" width="12" height="12" rx="2"></rect></svg>
          </button>
        </div>

        <div class="flex items-center gap-3">
          <!-- Driver selector -->
          <select
            id="driverSelect"
            class="bg-transparent text-sm text-monokai-fg/70 border-none outline-none cursor-pointer"
          >
            <option value="claude-sdk">Claude</option>
            <option value="openai">OpenAI</option>
            <option value="ollama">Ollama</option>
          </select>

          <!-- Send button -->
          <button
            id="sendBtn"
            class="w-8 h-8 rounded-lg bg-monokai-yellow flex items-center justify-center cursor-pointer hover:bg-monokai-yellow/90 transition-colors"
            title="Send (Enter)"
          >
            <svg class="w-4 h-4" fill="none" stroke="#1e1e1e" stroke-width="2.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 10.5L12 3m0 0l7.5 7.5M12 3v18"></path></svg>
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script client>
(() => {
  const API_BASE_URL = 'http://localhost:3008/voide';

  function init() {
    const stores = window.VoideStores;
    if (!stores) {
      setTimeout(init, 10);
      return;
    }

    const { appStore, appActions, chatStore, chatActions, settingsStore, settingsActions } = stores;

    // =========================================================================
    // Composables
    // =========================================================================
    const sounds = stores.useAudioCues();
    const voiceCommands = stores.useVoiceCommands();
    const audioStorage = stores.useAudioStorage();
    const drivingMode = stores.useDrivingMode({
      onWake: () => console.log('[Voide] Wake word detected'),
      onToggle: (enabled) => {
        updateDrivingModeUI();
        if (enabled && !isRecording) {
          startRecording();
        }
      }
    });

    // Audio recorder with callbacks
    const audioRecorder = stores.useAudioRecorder({
      onVolumeChange: updateVolumeIndicator,
      onDurationChange: updateRecordingTimer,
      onRecordingStop: handleRecordingStop
    });

    // Background transcription using speech recognition
    const speechRecognition = stores.useSpeechRecognition({
      continuous: true,
      interimResults: false,
      lang: 'en-US'
    });

    // State
    let isRecording = false;
    let hasRecording = false;
    let currentAudioUrl = null;
    let currentTranscript = '';
    let isTranscriptVisible = false;
    let audioElement = null;
    let isPlaying = false;

    // DOM Elements
    const micButton = document.getElementById('micButton');
    const micIcon = document.getElementById('micIcon');
    const inputContainer = document.getElementById('inputContainer');
    const textInput = document.getElementById('textInput');
    const sendBtn = document.getElementById('sendBtn');
    const stopBtn = document.getElementById('stopBtn');
    const driverSelect = document.getElementById('driverSelect');
    const drivingModeBtn = document.getElementById('drivingModeBtn');
    const drivingIcon = document.getElementById('drivingIcon');

    // Recording UI elements
    const recordingMode = document.getElementById('recordingMode');
    const recordingTimer = document.getElementById('recordingTimer');
    const inputRow = document.getElementById('inputRow');
    const volumeIndicator = document.getElementById('volumeIndicator');
    const volBars = [
      document.getElementById('volBar1'),
      document.getElementById('volBar2'),
      document.getElementById('volBar3'),
      document.getElementById('volBar4'),
      document.getElementById('volBar5')
    ];

    // Audio preview elements
    const audioPreview = document.getElementById('audioPreview');
    const audioPlayBtn = document.getElementById('audioPlayBtn');
    const audioPlayIcon = document.getElementById('audioPlayIcon');
    const audioDuration = document.getElementById('audioDuration');
    const audioDeleteBtn = document.getElementById('audioDeleteBtn');
    const transcriptToggle = document.getElementById('transcriptToggle');
    const transcriptChevron = document.getElementById('transcriptChevron');
    const transcriptContent = document.getElementById('transcriptContent');
    const transcriptText = document.getElementById('transcriptText');
    const transcriptStatus = document.getElementById('transcriptStatus');

    console.log('[VoideInputBar] Initialized with audio recording mode');

    // =========================================================================
    // Volume Indicator
    // =========================================================================

    function updateVolumeIndicator(level) {
      // level is 0-10, map to 5 bars
      const activeCount = Math.ceil(level / 2);
      volBars.forEach((bar, i) => {
        if (bar) {
          if (i < activeCount) {
            bar.classList.remove('bg-monokai-gray/30');
            bar.classList.add('bg-monokai-cyan');
          } else {
            bar.classList.remove('bg-monokai-cyan');
            bar.classList.add('bg-monokai-gray/30');
          }
        }
      });
    }

    // =========================================================================
    // Recording Timer
    // =========================================================================

    function updateRecordingTimer(seconds) {
      if (recordingTimer) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        recordingTimer.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
      }
    }

    // =========================================================================
    // Recording Flow
    // =========================================================================

    async function startRecording() {
      if (isRecording) return;

      const success = await audioRecorder.start();
      if (!success) {
        console.error('[Voide] Failed to start recording');
        return;
      }

      isRecording = true;
      hasRecording = false;
      currentTranscript = '';

      // Update UI
      if (recordingMode) recordingMode.classList.remove('hidden');
      if (inputRow) inputRow.classList.add('hidden');
      if (volumeIndicator) volumeIndicator.classList.remove('hidden');
      if (audioPreview) audioPreview.classList.add('hidden');
      if (inputContainer) {
        inputContainer.classList.remove('border-monokai-border');
        inputContainer.classList.add('border-monokai-pink');
      }
      if (micButton) {
        micButton.classList.remove('text-monokai-gray', 'hover:text-monokai-fg', 'hover:bg-monokai-bg');
        micButton.classList.add('text-monokai-pink', 'bg-monokai-pink/20');
      }
      if (micIcon) micIcon.setAttribute('stroke', '#ff6188');

      // Start background transcription
      startBackgroundTranscription();

      sounds.listening();
    }

    async function stopRecording() {
      if (!isRecording) return;

      const blob = await audioRecorder.stop();
      isRecording = false;

      // Stop background transcription
      stopBackgroundTranscription();

      if (blob) {
        hasRecording = true;
        currentAudioUrl = URL.createObjectURL(blob);

        // Create audio element for playback
        if (audioElement) {
          audioElement.pause();
          audioElement = null;
        }
        audioElement = new Audio(currentAudioUrl);
        audioElement.onended = () => {
          isPlaying = false;
          updatePlayButton();
        };

        // Update duration display
        const state = audioRecorder.get();
        if (audioDuration) {
          const mins = Math.floor(state.duration / 60);
          const secs = state.duration % 60;
          audioDuration.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Show audio preview
        if (audioPreview) audioPreview.classList.remove('hidden');

        // Update transcript text
        if (transcriptText) {
          transcriptText.value = currentTranscript || '';
        }
        updateTranscriptStatus();

        sounds.done();
      }

      // Reset UI
      if (recordingMode) recordingMode.classList.add('hidden');
      if (inputRow) inputRow.classList.remove('hidden');
      if (volumeIndicator) volumeIndicator.classList.add('hidden');
      if (inputContainer) {
        inputContainer.classList.remove('border-monokai-pink');
        inputContainer.classList.add('border-monokai-border');
      }
      if (micButton) {
        micButton.classList.remove('text-monokai-pink', 'bg-monokai-pink/20');
        micButton.classList.add('text-monokai-gray', 'hover:text-monokai-fg', 'hover:bg-monokai-bg');
      }
      if (micIcon) micIcon.setAttribute('stroke', 'currentColor');

      // Reset volume bars
      updateVolumeIndicator(0);
    }

    function toggleRecording() {
      if (isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    }

    function handleRecordingStop(blob, duration) {
      console.log('[Voide] Recording stopped:', duration, 'seconds');
    }

    // =========================================================================
    // Background Transcription
    // =========================================================================

    function startBackgroundTranscription() {
      if (!speechRecognition.isSupported) return;

      currentTranscript = '';

      speechRecognition.on('result', (data) => {
        if (data.transcript) {
          currentTranscript = voiceCommands.convertPunctuation(data.transcript);
          if (transcriptText && isTranscriptVisible) {
            transcriptText.value = currentTranscript;
          }
          updateTranscriptStatus();
        }
      });

      speechRecognition.on('end', () => {
        // Restart if still recording
        if (isRecording) {
          speechRecognition.start();
        }
      });

      speechRecognition.start();
    }

    function stopBackgroundTranscription() {
      speechRecognition.stop();
    }

    function updateTranscriptStatus() {
      if (transcriptStatus) {
        if (currentTranscript) {
          transcriptStatus.textContent = `(${currentTranscript.split(' ').length} words)`;
        } else {
          transcriptStatus.textContent = isRecording ? '(transcribing...)' : '';
        }
      }
    }

    // =========================================================================
    // Audio Playback
    // =========================================================================

    function togglePlayback() {
      if (!audioElement) return;

      if (isPlaying) {
        audioElement.pause();
        isPlaying = false;
      } else {
        audioElement.play();
        isPlaying = true;
      }
      updatePlayButton();
    }

    function updatePlayButton() {
      if (audioPlayIcon) {
        audioPlayIcon.innerHTML = isPlaying
          ? '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>'
          : '<path d="M8 5v14l11-7z"/>';
      }
    }

    function deleteRecording() {
      if (audioElement) {
        audioElement.pause();
        audioElement = null;
      }
      if (currentAudioUrl) {
        URL.revokeObjectURL(currentAudioUrl);
        currentAudioUrl = null;
      }
      hasRecording = false;
      currentTranscript = '';
      isPlaying = false;

      if (audioPreview) audioPreview.classList.add('hidden');
      if (transcriptText) transcriptText.value = '';

      audioRecorder.reset();
    }

    // =========================================================================
    // Transcript Toggle
    // =========================================================================

    function toggleTranscript() {
      isTranscriptVisible = !isTranscriptVisible;

      if (transcriptContent) {
        if (isTranscriptVisible) {
          transcriptContent.classList.remove('hidden');
        } else {
          transcriptContent.classList.add('hidden');
        }
      }
      if (transcriptChevron) {
        transcriptChevron.style.transform = isTranscriptVisible ? 'rotate(90deg)' : '';
      }
    }

    // =========================================================================
    // Driving Mode
    // =========================================================================

    function updateDrivingModeUI() {
      const isEnabled = drivingMode.isEnabled();
      if (drivingModeBtn) {
        drivingModeBtn.className = 'w-8 h-8 rounded-lg flex items-center justify-center transition-colors ' +
          (isEnabled ? 'text-monokai-green bg-monokai-green/20' : 'text-monokai-gray hover:text-monokai-fg hover:bg-monokai-bg');
        drivingModeBtn.title = isEnabled ? 'Driving Mode ON' : 'Driving Mode (hands-free)';
      }
      if (drivingIcon) {
        drivingIcon.setAttribute('stroke', isEnabled ? '#a9dc76' : 'currentColor');
      }
    }

    // =========================================================================
    // API & Command Processing
    // =========================================================================

    function checkBackendAPI() {
      return fetch(API_BASE_URL + '/state')
        .then(res => res.ok)
        .catch(() => false);
    }

    function saveChat() {
      const app = appStore.get();
      chatActions.saveCurrentChat(app.repoPath, app.currentDriver);
    }

    let saveChatDebounceTimer = null;
    function updateLastMessage(type, content) {
      chatActions.updateLastMessage(type, content);
      clearTimeout(saveChatDebounceTimer);
      saveChatDebounceTimer = setTimeout(saveChat, 500);
    }

    function addMessage(type, content, header) {
      const app = appStore.get();
      const driverName = app.currentDriver === 'claude-sdk' ? 'Claude SDK' :
                         app.currentDriver === 'openai' ? 'OpenAI' :
                         app.currentDriver === 'ollama' ? 'Ollama' : 'AI';
      const headerText = header || (type === 'user' ? 'You' : type === 'assistant' ? driverName : type === 'system' ? 'System' : 'Error');
      chatActions.addMessage(type, content, headerText);
      saveChat();
    }

    function detectMode(command) {
      const lower = command.toLowerCase().trim();
      const questionPatterns = [
        /^(what|why|how|when|where|who|which|can you explain|could you explain|please explain|tell me|describe|is it|are there|do you|does|did|will|would|should|could|can|may|might)/i,
        /\?$/,
        /^explain\s/i,
        /^describe\s/i,
        /^tell me\s/i,
        /^help me understand/i,
      ];
      const actionPatterns = [
        /^(fix|create|add|remove|delete|update|change|modify|refactor|implement|write|build|make|generate|run|execute|install|setup|configure|debug|test)/i,
        /^please (fix|create|add|remove|delete|update|change|modify|refactor|implement|write|build|make)/i,
        /\b(in my|in the|this|the) (code|file|project|app|application|repo|repository|codebase)\b/i,
      ];

      for (const pattern of actionPatterns) {
        if (pattern.test(lower)) return 'agentic';
      }
      for (const pattern of questionPatterns) {
        if (pattern.test(lower)) return 'simple';
      }
      return 'agentic';
    }

    function processWithStreaming(command) {
      return new Promise((resolve, reject) => {
        let fullContent = '';
        let currentEvent = '';
        const app = appStore.get();
        const chat = chatStore.get();
        const mode = detectMode(command);

        const history = chat.messages.slice(0, -1).map(m => ({
          role: m.type === 'user' ? 'user' : 'assistant',
          content: m.content
        })).filter(m => m.role === 'user' || m.role === 'assistant');

        fetch(API_BASE_URL + '/process/stream', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            command: command,
            driver: app.currentDriver,
            repository: app.repoPath,
            sessionId: chat.sessionId,
            history: history,
            mode: mode
          })
        }).then(response => {
          if (!response.ok) throw new Error('Stream request failed');

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';

          function readChunk() {
            reader.read().then(result => {
              if (result.done) {
                resolve({ message: fullContent, hasChanges: false });
                return;
              }

              buffer += decoder.decode(result.value, { stream: true });
              const lines = buffer.split('\n');
              buffer = lines.pop() || '';

              for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;

                if (trimmed.startsWith('event: ')) {
                  currentEvent = trimmed.substring(7);
                  continue;
                }

                if (trimmed.startsWith('data: ')) {
                  try {
                    const data = JSON.parse(trimmed.substring(6));

                    if (currentEvent === 'session' && data.sessionId) {
                      chatActions.setSessionId(data.sessionId);
                      saveChat();
                    } else if (currentEvent === 'chunk' && data.text) {
                      fullContent += data.text;
                      updateLastMessage('assistant', fullContent);
                    } else if (currentEvent === 'tool' && data.tool) {
                      let toolInfo = data.tool;
                      if (data.input) {
                        if (data.tool === 'Read' && data.input.file_path) {
                          toolInfo = 'Reading ' + data.input.file_path.split('/').pop();
                        } else if (data.tool === 'Edit' && data.input.file_path) {
                          toolInfo = 'Editing ' + data.input.file_path.split('/').pop();
                        } else if (data.tool === 'Write' && data.input.file_path) {
                          toolInfo = 'Writing ' + data.input.file_path.split('/').pop();
                        } else if (data.tool === 'Bash' && data.input.command) {
                          toolInfo = '$ ' + data.input.command.substring(0, 40);
                        } else if (data.tool === 'Glob' && data.input.pattern) {
                          toolInfo = 'Finding ' + data.input.pattern;
                        } else if (data.tool === 'Grep' && data.input.pattern) {
                          toolInfo = 'Searching "' + data.input.pattern + '"';
                        }
                      }
                      fullContent += '\n`' + toolInfo + '`';
                      updateLastMessage('assistant', fullContent);
                    } else if (currentEvent === 'done') {
                      resolve({ message: fullContent, hasChanges: data.hasChanges || false });
                      return;
                    } else if (currentEvent === 'error') {
                      reject(new Error(data.error || 'Stream error'));
                      return;
                    }
                  } catch (e) {}
                }
              }
              readChunk();
            }).catch(reject);
          }
          readChunk();
        }).catch(reject);
      });
    }

    function generateChatTitle(chatId, prompt) {
      fetch(API_BASE_URL + '/title', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt })
      })
      .then(res => res.json())
      .then(data => {
        if (data.title) chatActions.setChatTitle(chatId, data.title);
      })
      .catch(() => {});
    }

    function processCommand(command, audioId = null) {
      if (!command.trim()) return;

      const chat = chatStore.get();
      const app = appStore.get();
      let isNewChat = false;
      let newChatId = null;

      // Create message with audio reference if available
      const messageContent = audioId
        ? `[Voice message: ${command}]`
        : command;

      if (!chat.currentChatId) {
        newChatId = chatActions.startNewChat(app.repoPath, app.currentDriver, {
          type: 'user',
          content: messageContent,
          header: audioId ? 'You (voice)' : 'You',
          timestamp: Date.now(),
          audioId: audioId
        });
        isNewChat = true;
      } else {
        addMessage('user', messageContent, audioId ? 'You (voice)' : 'You');
      }

      appActions.setTerminalTitle('Processing...');

      if (!app.repoPath) {
        addMessage('error', 'Please enter a repository URL or path first.');
        appActions.setTerminalTitle('Voide - Ready');
        return;
      }

      appActions.setProcessing(true);
      addMessage('assistant', '...');

      if (drivingMode.isEnabled()) {
        sounds.processing();
      }

      checkBackendAPI().then(hasBackend => {
        if (hasBackend) {
          return processWithStreaming(command);
        } else if (app.currentDriver === 'mock') {
          return new Promise(resolve => {
            setTimeout(() => {
              resolve({
                message: '[Mock] Processing: "' + command + '"',
                hasChanges: false
              });
            }, 1500);
          });
        } else {
          return Promise.reject(new Error('Backend API not available.'));
        }
      }).then(response => {
        if (response.hasChanges) {
          appActions.setHasChanges(true);
          addMessage('system', 'Changes staged.');
        }
        appActions.setTerminalTitle('Voide - Ready');

        if (isNewChat && newChatId) {
          generateChatTitle(newChatId, command);
        }

        if (drivingMode.isEnabled()) {
          sounds.done();
          setTimeout(() => {
            if (response.message && window.voide?.speak) {
              window.voide.speak(response.message, 'auto-tts');
            }
          }, 400);
        }
      }).catch(error => {
        chatActions.removeLastMessage();
        addMessage('error', 'Failed: ' + error.message);
        appActions.setTerminalTitle('Voide - Error');

        if (drivingMode.isEnabled()) {
          sounds.error();
        }
      }).finally(() => {
        appActions.setProcessing(false);
      });
    }

    // =========================================================================
    // Input Handlers
    // =========================================================================

    function handleInputChange(e) {
      const el = e.target;
      el.style.height = 'auto';
      el.style.height = Math.min(el.scrollHeight, 160) + 'px';
      chatActions.setInputText(el.value);
    }

    function handleInputKeydown(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSend();
      }
    }

    async function handleSend() {
      // If we have a recording, send the transcription
      if (hasRecording && currentTranscript) {
        // Get transcript from textarea (user may have edited it)
        const transcript = transcriptText?.value?.trim() || currentTranscript;

        if (transcript) {
          // Save audio to storage
          const state = audioRecorder.get();
          let audioId = null;
          if (state.audioBlob && audioStorage.isSupported) {
            try {
              audioId = await audioStorage.save(
                state.audioBlob,
                state.duration,
                transcript,
                chatStore.get().currentChatId
              );
            } catch (e) {
              console.log('[Voide] Failed to save audio:', e);
            }
          }

          // Clear recording state
          deleteRecording();

          // Process the command
          processCommand(transcript, audioId);
        }
        return;
      }

      // Otherwise send text input
      const chat = chatStore.get();
      const text = chat.inputText.trim();

      if (text && !appStore.get().isProcessing) {
        chatActions.clearInput();
        if (textInput) {
          textInput.value = '';
          textInput.style.height = 'auto';
        }
        processCommand(text);
      }
    }

    function cancelProcessing() {
      fetch(API_BASE_URL + '/cancel', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({})
      }).then(() => {
        appActions.setProcessing(false);
        const messages = chatStore.get().messages;
        if (messages.length > 0) {
          const lastMsg = messages[messages.length - 1];
          if (lastMsg && lastMsg.type === 'assistant') {
            updateLastMessage('assistant', lastMsg.content + '\n\nâ€” *Stopped*');
          }
        }
      }).catch(() => {
        appActions.setProcessing(false);
      });
    }

    // =========================================================================
    // Event Bindings
    // =========================================================================

    micButton?.addEventListener('click', toggleRecording);
    sendBtn?.addEventListener('click', handleSend);
    stopBtn?.addEventListener('click', cancelProcessing);
    drivingModeBtn?.addEventListener('click', () => drivingMode.toggle());
    textInput?.addEventListener('input', handleInputChange);
    textInput?.addEventListener('keydown', handleInputKeydown);

    // Audio preview controls
    audioPlayBtn?.addEventListener('click', togglePlayback);
    audioDeleteBtn?.addEventListener('click', deleteRecording);
    transcriptToggle?.addEventListener('click', toggleTranscript);

    // Driver selector
    const initialDriver = appStore.get().currentDriver || 'claude-sdk';
    if (driverSelect) driverSelect.value = initialDriver;
    driverSelect?.addEventListener('change', (e) => {
      appActions.setDriver(e.target.value);
    });

    // Global keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && !e.repeat) {
        const active = document.activeElement;
        const isInput = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA');
        if (!isInput) {
          e.preventDefault();
          toggleRecording();
        }
      }
    });

    // =========================================================================
    // State Subscriptions
    // =========================================================================

    const thinkingIndicator = document.getElementById('thinkingIndicator');
    const thinkingTimer = document.getElementById('thinkingTimer');
    let processingTimerInterval = null;
    let processingTimerStart = null;

    function startProcessingTimer() {
      processingTimerStart = Date.now();
      if (thinkingTimer) thinkingTimer.textContent = '0.0s';
      processingTimerInterval = setInterval(() => {
        if (thinkingTimer && processingTimerStart) {
          const elapsed = ((Date.now() - processingTimerStart) / 1000).toFixed(1);
          thinkingTimer.textContent = `${elapsed}s`;
        }
      }, 100);
    }

    function stopProcessingTimer() {
      if (processingTimerInterval) {
        clearInterval(processingTimerInterval);
        processingTimerInterval = null;
      }
      processingTimerStart = null;
    }

    appStore.subscribe((state) => {
      if (thinkingIndicator) {
        if (state.isProcessing) {
          thinkingIndicator.classList.remove('hidden');
          if (!processingTimerInterval) startProcessingTimer();
        } else {
          thinkingIndicator.classList.add('hidden');
          stopProcessingTimer();
        }
      }

      if (stopBtn) {
        if (state.isProcessing) {
          stopBtn.classList.remove('hidden');
        } else {
          stopBtn.classList.add('hidden');
        }
      }

      if (driverSelect && state.currentDriver) {
        driverSelect.value = state.currentDriver;
      }
    });

    // =========================================================================
    // Expose to window.voide
    // =========================================================================

    window.voide = window.voide || {};
    Object.assign(window.voide, {
      toggleRecording,
      startRecording,
      stopRecording,
      handleSend,
      cancelProcessing,
      processCommand,
      addMessage,
      toggleDrivingMode: () => drivingMode.toggle(),
      isDrivingMode: () => drivingMode.isEnabled(),
      sounds,
      audioRecorder,
      audioStorage
    });
  }

  init();
})();
</script>

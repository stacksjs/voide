<template>
  <div class="relative">
    <div class="bg-monokai-bg border border-monokai-border rounded-2xl p-5">
      <div class="flex items-start gap-5">
        <!-- Voice Button -->
        <div class="flex flex-col items-center gap-2 w-20 flex-shrink-0">
          <button
            id="micButton"
            class="w-16 h-16 rounded-full bg-monokai-bg-dark border-2 border-monokai-border flex items-center justify-center cursor-pointer transition-all hover:border-monokai-pink"
            title="Click to toggle voice input (or press Space)"
          >
            <svg id="micIcon" class="w-6 h-6" fill="none" stroke="#727072" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18.75a6 6 0 006-6v-1.5m-6 7.5a6 6 0 01-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 01-3-3V4.5a3 3 0 116 0v8.25a3 3 0 01-3 3z"></path></svg>
          </button>
          <span id="statusHint" class="text-[10px] text-monokai-gray text-center w-full">Click to speak</span>
        </div>

        <!-- Input Area -->
        <div class="flex-1 flex flex-col gap-3">
          <!-- Text Input -->
          <div
            id="inputContainer"
            class="flex items-end gap-3 bg-monokai-bg-dark border border-monokai-border rounded-xl px-4 py-3"
          >
            <textarea
              id="textInput"
              class="flex-1 bg-transparent text-sm text-monokai-fg border-none outline-none resize-none min-h-[24px] max-h-[120px] leading-6 placeholder-monokai-gray"
              placeholder="Type a command or ask a question..."
            ></textarea>
            <!-- Send Button (shown when not processing) -->
            <button
              id="sendBtn"
              class="flex-shrink-0 w-10 h-10 rounded-xl bg-monokai-cyan flex items-center justify-center cursor-pointer hover:bg-monokai-cyan/90 transition-colors"
              title="Send (Enter)"
            >
              <svg class="w-5 h-5" fill="none" stroke="#ffffff" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 10.5L12 3m0 0l7.5 7.5M12 3v18"></path></svg>
            </button>
            <!-- Stop Button (shown when processing) -->
            <button
              id="stopBtn"
              class="hidden flex-shrink-0 w-10 h-10 rounded-xl bg-monokai-pink flex items-center justify-center cursor-pointer hover:bg-monokai-pink/90 transition-colors"
              title="Stop processing"
            >
              <svg class="w-5 h-5" fill="#ffffff" viewBox="0 0 24 24"><rect x="6" y="6" width="12" height="12" rx="2"></rect></svg>
            </button>
          </div>

          <!-- Hints -->
          <div class="flex items-center justify-between text-[10px] text-monokai-gray px-1">
            <div class="flex items-center gap-3">
              <span><kbd class="px-1.5 py-0.5 bg-monokai-bg-dark rounded text-monokai-fg/50">Enter</kbd> send</span>
              <span><kbd class="px-1.5 py-0.5 bg-monokai-bg-dark rounded text-monokai-fg/50">Shift+Enter</kbd> new line</span>
              <span><kbd class="px-1.5 py-0.5 bg-monokai-bg-dark rounded text-monokai-fg/50">Space</kbd> voice</span>
            </div>
            <span id="charCountDisplay"></span>
          </div>
        </div>

        <!-- Action Buttons -->
        <div class="flex flex-col gap-2">
          <button
            id="commitBtn"
            class="px-4 py-2 text-sm font-medium bg-monokai-green text-monokai-bg rounded-xl cursor-pointer disabled:opacity-40 disabled:cursor-not-allowed hover:bg-monokai-green/90 transition-colors"
            disabled
          >Commit</button>
          <button
            id="pushBtn"
            class="px-4 py-2 text-sm font-medium bg-monokai-bg-dark text-monokai-fg border border-monokai-border rounded-xl cursor-pointer disabled:opacity-40 disabled:cursor-not-allowed hover:border-monokai-gray transition-colors"
            disabled
          >Push</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script client>
(() => {
  const API_BASE_URL = 'http://localhost:3008/voide';

  function init() {
    const stores = window.VoideStores;
    if (!stores) {
      setTimeout(init, 10);
      return;
    }

    const { appStore, appActions, chatStore, chatActions, settingsStore, settingsActions } = stores;

    // Speech recognition setup
    const speechRecognition = stores.useSpeechRecognition({
      continuous: false,
      interimResults: true,
      lang: 'en-US'
    });

    let accumulatedTranscript = '';

    // DOM Elements
    const micButton = document.getElementById('micButton');
    const micIcon = document.getElementById('micIcon');
    const statusHint = document.getElementById('statusHint');
    const inputContainer = document.getElementById('inputContainer');
    const textInput = document.getElementById('textInput');
    const sendBtn = document.getElementById('sendBtn');
    const stopBtn = document.getElementById('stopBtn');
    const commitBtn = document.getElementById('commitBtn');
    const pushBtn = document.getElementById('pushBtn');
    const charCountDisplay = document.getElementById('charCountDisplay');

    console.log('[VoideInputBar] Initialized');

    // =========================================================================
    // API Helpers
    // =========================================================================

    function checkBackendAPI() {
      return fetch(API_BASE_URL + '/state')
        .then(res => res.ok)
        .catch(() => false);
    }

    function saveChat() {
      const app = appStore.get();
      chatActions.saveCurrentChat(app.repoPath, app.currentDriver);
    }

    let saveChatDebounceTimer = null;
    function updateLastMessage(type, content) {
      chatActions.updateLastMessage(type, content);
      clearTimeout(saveChatDebounceTimer);
      saveChatDebounceTimer = setTimeout(saveChat, 500);
    }

    function addMessage(type, content, header) {
      const app = appStore.get();
      const driverName = app.currentDriver === 'claude-sdk' ? 'Claude SDK' :
                         app.currentDriver === 'openai' ? 'OpenAI' :
                         app.currentDriver === 'ollama' ? 'Ollama' : 'AI';
      const headerText = header || (type === 'user' ? 'You' : type === 'assistant' ? driverName : type === 'system' ? 'System' : 'Error');
      chatActions.addMessage(type, content, headerText);
      saveChat();
    }

    // =========================================================================
    // Command Processing
    // =========================================================================

    function processWithStreaming(command) {
      return new Promise((resolve, reject) => {
        let fullContent = '';
        let currentEvent = '';
        const app = appStore.get();
        const chat = chatStore.get();

        fetch(API_BASE_URL + '/process/stream', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            command: command,
            driver: app.currentDriver,
            repository: app.repoPath,
            sessionId: chat.sessionId
          })
        }).then(response => {
          if (!response.ok) throw new Error('Stream request failed');

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';

          function readChunk() {
            reader.read().then(result => {
              if (result.done) {
                resolve({ message: fullContent, hasChanges: false });
                return;
              }

              buffer += decoder.decode(result.value, { stream: true });
              const lines = buffer.split('\n');
              buffer = lines.pop() || '';

              for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;

                if (trimmed.startsWith('event: ')) {
                  currentEvent = trimmed.substring(7);
                  continue;
                }

                if (trimmed.startsWith('data: ')) {
                  try {
                    const data = JSON.parse(trimmed.substring(6));

                    if (currentEvent === 'session' && data.sessionId) {
                      chatActions.setSessionId(data.sessionId);
                    } else if (currentEvent === 'chunk' && data.text) {
                      fullContent += data.text;
                      updateLastMessage('assistant', fullContent);
                    } else if (currentEvent === 'tool' && data.tool) {
                      let toolInfo = data.tool;
                      if (data.input) {
                        if (data.tool === 'Read' && data.input.file_path) {
                          toolInfo = 'Reading ' + data.input.file_path.split('/').pop();
                        } else if (data.tool === 'Edit' && data.input.file_path) {
                          toolInfo = 'Editing ' + data.input.file_path.split('/').pop();
                        } else if (data.tool === 'Write' && data.input.file_path) {
                          toolInfo = 'Writing ' + data.input.file_path.split('/').pop();
                        } else if (data.tool === 'Bash' && data.input.command) {
                          toolInfo = '$ ' + data.input.command.substring(0, 40) + (data.input.command.length > 40 ? '...' : '');
                        } else if (data.tool === 'Glob' && data.input.pattern) {
                          toolInfo = 'Finding ' + data.input.pattern;
                        } else if (data.tool === 'Grep' && data.input.pattern) {
                          toolInfo = 'Searching "' + data.input.pattern + '"';
                        } else if (data.tool === 'Task' && data.input.description) {
                          toolInfo = 'Task: ' + data.input.description;
                        }
                      }
                      fullContent += '\n`' + toolInfo + '`';
                      updateLastMessage('assistant', fullContent);
                    } else if (currentEvent === 'prompt') {
                      chatActions.setPendingPrompt({
                        id: data.id || Date.now().toString(),
                        text: data.text || 'Please select an option:',
                        options: data.options || ['y', 'n'],
                        labels: data.labels || data.options || ['Yes', 'No']
                      });
                    } else if (currentEvent === 'done') {
                      chatActions.clearPendingPrompt();
                      resolve({ message: fullContent, hasChanges: data.hasChanges || false });
                      return;
                    } else if (currentEvent === 'error') {
                      chatActions.clearPendingPrompt();
                      reject(new Error(data.error || 'Stream error'));
                      return;
                    }
                  } catch (e) {}
                }
              }
              readChunk();
            }).catch(reject);
          }
          readChunk();
        }).catch(reject);
      });
    }

    function processCommand(command) {
      if (!command.trim()) return;

      const chat = chatStore.get();
      const app = appStore.get();

      if (!chat.currentChatId) {
        chatActions.startNewChat(app.repoPath, app.currentDriver, {
          type: 'user',
          content: command,
          header: 'You',
          timestamp: Date.now()
        });
      } else {
        addMessage('user', command);
      }

      appActions.setTerminalTitle('Processing...');

      if (!app.repoPath) {
        addMessage('error', 'Please enter a repository URL or path first.');
        appActions.setTerminalTitle('Voide - Ready');
        return;
      }

      appActions.setProcessing(true);
      addMessage('assistant', '...');

      checkBackendAPI().then(hasBackend => {
        if (hasBackend) {
          return processWithStreaming(command);
        } else if (app.currentDriver === 'mock') {
          return new Promise(resolve => {
            setTimeout(() => {
              resolve({
                message: '[Mock] Processing: "' + command + '"\n\nThis is a simulated response.',
                hasChanges: command.toLowerCase().includes('fix')
              });
            }, 1500);
          });
        } else {
          return Promise.reject(new Error('Backend API not available. Start the server at localhost:3008.'));
        }
      }).then(response => {
        if (response.hasChanges) {
          appActions.setHasChanges(true);
          addMessage('system', 'Changes staged. Click "Commit Changes" to create a commit.');
        }
        appActions.setTerminalTitle('Voide - Ready');
      }).catch(error => {
        chatActions.removeLastMessage();
        addMessage('error', 'Failed: ' + error.message);
        appActions.setTerminalTitle('Voide - Error');
      }).finally(() => {
        appActions.setProcessing(false);
      });
    }

    // =========================================================================
    // Input Handlers
    // =========================================================================

    function handleInputChange(e) {
      const el = e.target;
      el.style.height = 'auto';
      el.style.height = Math.min(el.scrollHeight, 120) + 'px';
      chatActions.setInputText(el.value);
    }

    function handleInputKeydown(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleTextSubmit();
      }
    }

    function handleTextSubmit() {
      const chat = chatStore.get();
      const text = chat.inputText.trim();
      if (text && !appStore.get().isProcessing) {
        chatActions.clearInput();
        if (textInput) {
          textInput.value = '';
          textInput.style.height = 'auto';
        }
        processCommand(text);
      }
    }

    function handleSendClick() {
      handleTextSubmit();
    }

    // =========================================================================
    // Speech Recognition
    // =========================================================================

    // Convert spoken punctuation words to actual symbols
    const punctuationMap = [
      // Common punctuation
      [/\bperiod\b/gi, '.'],
      [/\bfull stop\b/gi, '.'],
      [/\bcomma\b/gi, ','],
      [/\bquestion mark\b/gi, '?'],
      [/\bexclamation mark\b/gi, '!'],
      [/\bexclamation point\b/gi, '!'],
      [/\bcolon\b/gi, ':'],
      [/\bsemicolon\b/gi, ';'],
      [/\bsemi colon\b/gi, ';'],
      // Quotes
      [/\bquote\b/gi, '"'],
      [/\bend quote\b/gi, '"'],
      [/\bopen quote\b/gi, '"'],
      [/\bclose quote\b/gi, '"'],
      [/\bsingle quote\b/gi, "'"],
      [/\bapostrophe\b/gi, "'"],
      // Brackets
      [/\bopen paren\b/gi, '('],
      [/\bclose paren\b/gi, ')'],
      [/\bopen parenthesis\b/gi, '('],
      [/\bclose parenthesis\b/gi, ')'],
      [/\bleft paren\b/gi, '('],
      [/\bright paren\b/gi, ')'],
      [/\bopen bracket\b/gi, '['],
      [/\bclose bracket\b/gi, ']'],
      [/\bleft bracket\b/gi, '['],
      [/\bright bracket\b/gi, ']'],
      [/\bopen brace\b/gi, '{'],
      [/\bclose brace\b/gi, '}'],
      [/\bleft brace\b/gi, '{'],
      [/\bright brace\b/gi, '}'],
      [/\bopen curly\b/gi, '{'],
      [/\bclose curly\b/gi, '}'],
      // Special characters
      [/\bhyphen\b/gi, '-'],
      [/\bdash\b/gi, '-'],
      [/\bunderscore\b/gi, '_'],
      [/\bslash\b/gi, '/'],
      [/\bforward slash\b/gi, '/'],
      [/\bbackslash\b/gi, '\\'],
      [/\bback slash\b/gi, '\\'],
      [/\bpipe\b/gi, '|'],
      [/\bampersand\b/gi, '&'],
      [/\bat sign\b/gi, '@'],
      [/\bhash\b/gi, '#'],
      [/\bhashtag\b/gi, '#'],
      [/\bpound sign\b/gi, '#'],
      [/\basterisk\b/gi, '*'],
      [/\bstar\b/gi, '*'],
      [/\bpercent\b/gi, '%'],
      [/\bpercent sign\b/gi, '%'],
      [/\bcaret\b/gi, '^'],
      [/\btilde\b/gi, '~'],
      [/\bbacktick\b/gi, '`'],
      [/\bgrave\b/gi, '`'],
      [/\bellipsis\b/gi, '...'],
      [/\bdot dot dot\b/gi, '...'],
      // Comparison operators
      [/\bequals\b/gi, '='],
      [/\bequal sign\b/gi, '='],
      [/\bless than\b/gi, '<'],
      [/\bgreater than\b/gi, '>'],
      // New line
      [/\bnew line\b/gi, '\n'],
      [/\bnewline\b/gi, '\n'],
    ];

    function convertSpokenPunctuation(text) {
      let result = text;
      for (const [pattern, replacement] of punctuationMap) {
        result = result.replace(pattern, replacement);
      }
      // Clean up extra spaces around punctuation
      result = result.replace(/\s+([.,!?;:])/g, '$1');
      result = result.replace(/([(\[{])\s+/g, '$1');
      result = result.replace(/\s+([)\]}])/g, '$1');
      return result;
    }

    function initSpeechRecognition() {
      if (!speechRecognition.isSupported) {
        appActions.setSpeechSupported(false);
        return false;
      }

      speechRecognition.on('start', () => {
        const app = appStore.get();
        if (!app.isRecording) {
          appActions.setTranscript('');
        }
        appActions.setRecording(true);
      });

      speechRecognition.on('result', (data) => {
        const rawTranscript = accumulatedTranscript + data.transcript;
        const trimmed = rawTranscript.trim().toLowerCase();

        // "reset" clears the prompt
        if (trimmed.endsWith(' reset') || trimmed === 'reset') {
          accumulatedTranscript = '';
          appActions.setTranscript('');
          chatActions.setInputText('');
          if (textInput) {
            textInput.value = '';
            textInput.style.height = 'auto';
          }
          return;
        }

        // "backspace" deletes last word only (preserves newlines)
        if (trimmed.endsWith(' backspace') || trimmed === 'backspace') {
          // Remove "backspace" from the end
          let text = rawTranscript.replace(/\s*backspace\s*$/i, '');
          // Remove only the last word and horizontal whitespace before it (preserve newlines)
          // [ \t]* = optional spaces/tabs, [^ \t\n]+ = word chars, [ \t]*$ = trailing spaces/tabs
          text = text.replace(/[ \t]*[^ \t\n]+[ \t]*$/, '');
          const newTranscript = convertSpokenPunctuation(text);
          accumulatedTranscript = newTranscript + (newTranscript ? ' ' : '');
          appActions.setTranscript(newTranscript);
          chatActions.setInputText(newTranscript);
          if (textInput) {
            textInput.value = newTranscript;
            textInput.style.height = 'auto';
            textInput.style.height = Math.min(textInput.scrollHeight, 120) + 'px';
          }
          return;
        }

        // "go" submits the prompt
        if (trimmed.endsWith(' go') || trimmed === 'go') {
          const cleanTranscript = convertSpokenPunctuation(rawTranscript.replace(/\s*go\s*$/i, '').trim());
          if (cleanTranscript) {
            appActions.setRecording(false);
            speechRecognition.stop();
            accumulatedTranscript = '';
            appActions.setTranscript('');
            chatActions.clearInput();
            if (textInput) {
              textInput.value = '';
              textInput.style.height = 'auto';
            }
            setTimeout(() => processCommand(cleanTranscript), 100);
          }
          return;
        }

        // Convert spoken punctuation to symbols and update display
        const fullTranscript = convertSpokenPunctuation(rawTranscript);
        appActions.setTranscript(fullTranscript);
      });

      speechRecognition.on('end', () => {
        const app = appStore.get();
        if (app.isRecording) {
          // Store converted transcript for continuation
          accumulatedTranscript = (app.transcript || '') + ' ';
          speechRecognition.start();
        } else {
          accumulatedTranscript = '';
        }
      });

      speechRecognition.on('error', (data) => {
        stopRecording();
        if (data.code !== 'aborted' && data.code !== 'no-speech') {
          addMessage('error', data.message);
        }
      });

      appActions.setSpeechSupported(true);
      return true;
    }

    function startRecording() {
      const app = appStore.get();
      if (!app.speechSupported || app.isRecording) return;
      appActions.setTranscript('');
      accumulatedTranscript = '';
      speechRecognition.start();
    }

    function stopRecording() {
      const app = appStore.get();
      if (app.transcript && app.transcript.trim()) {
        chatActions.setInputText(app.transcript.trim());
        if (textInput) textInput.value = app.transcript.trim();
      }
      appActions.setRecording(false);
      speechRecognition.stop();
    }

    function toggleRecording() {
      const app = appStore.get();
      if (app.isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    }

    // =========================================================================
    // Git Actions
    // =========================================================================

    function commitChanges() {
      if (!appStore.get().hasChanges) return;

      addMessage('system', 'Creating commit...');

      checkBackendAPI().then(hasBackend => {
        if (hasBackend) {
          return fetch(API_BASE_URL + '/commit', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          }).then(res => res.json());
        }
        return { success: true, hash: 'mock-commit-hash' };
      }).then(response => {
        addMessage('system', 'Committed: ' + (response.hash || 'success'));
        appActions.setHasChanges(false);
      }).catch(error => {
        addMessage('error', 'Failed: ' + error.message);
      });
    }

    function pushChanges() {
      addMessage('system', 'Pushing to remote...');

      checkBackendAPI().then(hasBackend => {
        if (hasBackend) {
          return fetch(API_BASE_URL + '/push', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
        }
        return Promise.resolve();
      }).then(() => {
        addMessage('system', 'Pushed successfully.');
      }).catch(error => {
        addMessage('error', 'Failed: ' + error.message);
      });
    }

    function cancelProcessing() {
      fetch(API_BASE_URL + '/cancel', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      }).then(res => res.json()).then(data => {
        if (data.success) {
          appActions.setProcessing(false);
          const messages = chatStore.get().messages;
          if (messages.length > 0) {
            updateLastMessage('assistant', messages[messages.length - 1]?.content + '\n\n*Process stopped by user*');
          }
          addMessage('system', 'Process stopped.');
        }
      }).catch(error => {
        console.error('Failed to cancel:', error);
      });
    }

    // =========================================================================
    // Event Bindings
    // =========================================================================

    // Button click handlers
    micButton?.addEventListener('click', toggleRecording);
    sendBtn?.addEventListener('click', handleSendClick);
    stopBtn?.addEventListener('click', cancelProcessing);
    commitBtn?.addEventListener('click', commitChanges);
    pushBtn?.addEventListener('click', pushChanges);

    // Text input handlers
    textInput?.addEventListener('input', handleInputChange);
    textInput?.addEventListener('keydown', handleInputKeydown);

    // Global keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && !e.repeat) {
        const active = document.activeElement;
        const isInput = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA');
        if (!isInput) {
          e.preventDefault();
          toggleRecording();
        }
      }
    });

    // =========================================================================
    // State Subscriptions
    // =========================================================================

    appStore.subscribe((state) => {
      // Toggle send/stop buttons
      if (sendBtn && stopBtn) {
        if (state.isProcessing) {
          sendBtn.classList.add('hidden');
          stopBtn.classList.remove('hidden');
        } else {
          sendBtn.classList.remove('hidden');
          stopBtn.classList.add('hidden');
        }
      }

      // Mic button state
      if (micButton) {
        micButton.className = 'w-16 h-16 rounded-full bg-monokai-bg-dark border-2 flex items-center justify-center cursor-pointer transition-all hover:border-monokai-pink ' +
          (state.isRecording ? 'border-monokai-pink' : 'border-monokai-border');
      }
      if (micIcon) micIcon.setAttribute('stroke', state.isRecording ? '#ff6188' : '#727072');
      if (statusHint) statusHint.textContent = state.isRecording ? 'Listening...' : 'Click to speak';

      // Input container state
      if (inputContainer) {
        inputContainer.className = 'flex items-end gap-3 bg-monokai-bg-dark border rounded-xl px-4 py-3 ' +
          (state.isRecording ? 'border-monokai-pink' : 'border-monokai-border');
      }

      // Update placeholder and value based on recording state
      if (textInput) {
        textInput.placeholder = state.isRecording ? 'Listening... speak now' : 'Type a command or ask a question...';
        if (state.isRecording && state.transcript) {
          textInput.value = state.transcript;
          textInput.style.height = 'auto';
          textInput.style.height = Math.min(textInput.scrollHeight, 120) + 'px';
          chatActions.setInputText(state.transcript);
        }
      }

      // Commit/Push button states
      const canAct = state.hasChanges && !state.isProcessing;
      if (commitBtn) commitBtn.disabled = !canAct;
      if (pushBtn) pushBtn.disabled = !canAct;
    });

    chatStore.subscribe((state) => {
      if (charCountDisplay) {
        charCountDisplay.textContent = state.charCount > 0 ? state.charCount + ' chars' : '';
      }
    });

    // Initialize speech recognition
    initSpeechRecognition();

    // Expose to window.voide for other components
    window.voide = window.voide || {};
    Object.assign(window.voide, {
      toggleRecording,
      startRecording,
      stopRecording,
      handleInputChange,
      handleInputKeydown,
      handleSendClick,
      handleTextSubmit,
      commitChanges,
      pushChanges,
      cancelProcessing,
      processCommand,
      addMessage
    });
  }

  init();
})();
</script>

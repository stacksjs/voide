<aside class="w-56 bg-monokai-bg border-r border-monokai-border flex flex-col h-full overflow-hidden">
    <!-- New Chat Button -->
    <div class="p-3">
      <button
        id="newChatBtn"
        class="w-full flex items-center gap-2 px-3 py-2.5 text-sm font-medium text-monokai-fg bg-monokai-bg-dark border border-monokai-border hover:border-monokai-gray rounded-xl transition-all"
      >
        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15"></path>
        </svg>
        New chat
      </button>
    </div>

    <!-- Search -->
    <div class="px-3 pb-2">
      <input
        id="chatSearch"
        type="text"
        placeholder="Search chats..."
        class="w-full bg-monokai-bg-dark border border-monokai-border rounded-lg px-3 py-1.5 text-xs text-monokai-fg placeholder-monokai-gray focus:border-monokai-purple focus:outline-none transition-all"
      />
    </div>

    <!-- Your chats -->
    <div class="flex-1 overflow-y-auto">
      <div class="px-4 py-2">
        <span class="text-xs text-monokai-gray">Your chats</span>
      </div>
      <div id="chatList" class="px-2 space-y-0.5">
        <!-- Chats will be rendered here -->
      </div>
    </div>
</aside>

<script client>
(() => {
  const { appStore, chatStore } = window.__STX_STORES__;
  // DOM Elements
  const chatList = document.getElementById('chatList');
  const newChatBtn = document.getElementById('newChatBtn');
  const chatSearch = document.getElementById('chatSearch');

  let searchQuery = '';

  console.log('[VoideSidebar] Initialized');

  // =========================================================================
  // Helper Functions
  // =========================================================================

  function getFirstMessage(messages) {
    if (!messages || messages.length === 0) return null;
    const userMsg = messages.find(m => m.type === 'user');
    return userMsg ? userMsg.content : null;
  }

  function getChatTitle(chat) {
    // Use AI-generated title if available
    if (chat.title) return chat.title;

    // Fallback to first message
    const firstMessage = getFirstMessage(chat.messages);
    if (!firstMessage) return 'New Chat';
    const clean = firstMessage.replace(/\n/g, ' ').trim();
    return clean.length > 28 ? clean.substring(0, 28) + '...' : clean;
  }

  function chatMatchesSearch(chat, query) {
    if (!query) return true;
    const lowerQuery = query.toLowerCase();
    const title = getChatTitle(chat).toLowerCase();
    if (title.includes(lowerQuery)) return true;

    // Also search in message content
    for (const msg of (chat.messages || [])) {
      if (msg.content && msg.content.toLowerCase().includes(lowerQuery)) {
        return true;
      }
    }
    return false;
  }

  // =========================================================================
  // Render Chat List
  // =========================================================================

  function renderChatList() {
    const chatsObj = chatStore.getAllChats() || {};
    const chats = Object.values(chatsObj);
    const currentChatId = chatStore.currentChatId;

    if (!chatList) return;

    if (chats.length === 0) {
      chatList.innerHTML = '<div class="px-3 py-4 text-xs text-monokai-gray text-center">No chats yet</div>';
      return;
    }

    // Filter by search query
    const filteredChats = chats.filter(chat => chatMatchesSearch(chat, searchQuery));

    if (filteredChats.length === 0) {
      chatList.innerHTML = '<div class="px-3 py-4 text-xs text-monokai-gray text-center">No matching chats</div>';
      return;
    }

    const sortedChats = [...filteredChats].sort((a, b) => (b.updatedAt || b.createdAt) - (a.updatedAt || a.createdAt));

    chatList.innerHTML = sortedChats.map(chat => {
      const isActive = chat.id === currentChatId;
      const title = getChatTitle(chat);

      return `
        <div
          class="chat-item group flex items-center px-3 py-2 rounded-lg cursor-pointer transition-colors ${isActive ? 'bg-monokai-bg-dark' : 'hover:bg-monokai-bg-dark/50'}"
          data-chat-id="${chat.id}"
        >
          <span class="flex-1 text-sm ${isActive ? 'text-monokai-fg font-medium' : 'text-monokai-fg/80'} truncate">${title}</span>
          <button
            class="delete-btn opacity-0 group-hover:opacity-100 w-5 h-5 flex items-center justify-center text-monokai-gray hover:text-monokai-pink transition-all"
            data-chat-id="${chat.id}"
            title="Delete chat"
          >
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
          </button>
        </div>
      `;
    }).join('');

    // Bind click handlers for chat items
    chatList.querySelectorAll('.chat-item').forEach(item => {
      item.addEventListener('click', (e) => {
        // Don't load chat if clicking delete button
        if (e.target.closest('.delete-btn')) return;
        const chatId = item.dataset.chatId;
        loadChat(chatId);
      });
    });

    // Bind click handlers for delete buttons
    chatList.querySelectorAll('.delete-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const chatId = btn.dataset.chatId;
        confirmDeleteChat(chatId);
      });
    });
  }

  function confirmDeleteChat(chatId) {
    const chat = Object.values(chatStore.getAllChats() || {}).find(c => c.id === chatId);
    const title = chat ? getChatTitle(chat) : 'this chat';

    if (confirm(`Delete "${title}"?\n\nThis action cannot be undone.`)) {
      deleteChat(chatId);
    }
  }

  function deleteChat(chatId) {
    chatStore.deleteChat(chatId);

    // If we deleted the current chat, start a new one
    if (chatId === chatStore.currentChatId) {
      chatStore.newChat();
      history.pushState({}, '', '/');
    }

    renderChatList();
  }

  // =========================================================================
  // Chat Actions
  // =========================================================================

  function loadChat(chatId) {
    if (chatId === chatStore.currentChatId) return;

    const loaded = chatStore.loadChat(chatId);
    if (loaded) {
      // Note: The loaded chat's repoPath/driver are now in chatStore state
      // We can access them to update appStore if needed
      history.pushState({}, '', '/chat/' + chatId);
      renderChatList();
    }
  }

  function newChat() {
    chatStore.newChat();
    appStore.setRepoPath('');
    history.pushState({}, '', '/');
    renderChatList();
  }

  // =========================================================================
  // Event Bindings
  // =========================================================================

  newChatBtn?.addEventListener('click', newChat);

  // Search input handler
  chatSearch?.addEventListener('input', (e) => {
    searchQuery = e.target.value.trim();
    renderChatList();
  });

  chatStore.$subscribe(() => {
    renderChatList();
  });

  // Re-render periodically to pick up title updates
  setInterval(() => {
    renderChatList();
  }, 2000);

  renderChatList();

  // =========================================================================
  // Expose to window.voide
  // =========================================================================

  window.voide = window.voide || {};
  Object.assign(window.voide, {
    renderChatList,
    newChat,
    deleteChat
  });
})();
</script>
